#!/usr/bin/env python
# -*- coding: utf-8 -*-
#
# Copyright 2025 Trevor Wiseman.
#
# SPDX-License-Identifier: GPL-3.0-or-later
#


import numpy as np
from gnuradio import gr
from scipy.signal import fftconvolve

class correlator(gr.sync_block):
    """
    docstring for block correlator
    """
    def __init__(self, sps=2):
        gr.sync_block.__init__(self,
            name="correlator",
            in_sig=[np.complex64],
            out_sig=[np.complex64])
        self.startSequence = np.array([(0.7071067811865475+0.7071067811865475j), (0.7071067811865475+0.7071067811865475j), (0.7071067811865475-0.7071067811865475j), 
                                       (-0.7071067811865475+0.7071067811865475j), (0.7071067811865475-0.7071067811865475j), (0.7071067811865475-0.7071067811865475j), 
                                       (-0.7071067811865475+0.7071067811865475j), (-0.7071067811865475-0.7071067811865475j), (-0.7071067811865475-0.7071067811865475j), 
                                       (0.7071067811865475-0.7071067811865475j), (0.7071067811865475-0.7071067811865475j), (0.7071067811865475+0.7071067811865475j), 
                                       (0.7071067811865475-0.7071067811865475j), (0.7071067811865475+0.7071067811865475j), (-0.7071067811865475-0.7071067811865475j), 
                                       (-0.7071067811865475+0.7071067811865475j), (0.7071067811865475+0.7071067811865475j), (0.7071067811865475+0.7071067811865475j), 
                                       (0.7071067811865475-0.7071067811865475j), (-0.7071067811865475+0.7071067811865475j), (0.7071067811865475-0.7071067811865475j), 
                                       (0.7071067811865475-0.7071067811865475j), (-0.7071067811865475+0.7071067811865475j), (-0.7071067811865475-0.7071067811865475j), 
                                       (-0.7071067811865475-0.7071067811865475j), (0.7071067811865475-0.7071067811865475j), (0.7071067811865475-0.7071067811865475j), 
                                       (0.7071067811865475+0.7071067811865475j), (0.7071067811865475-0.7071067811865475j), (0.7071067811865475+0.7071067811865475j), 
                                       (-0.7071067811865475-0.7071067811865475j), (-0.7071067811865475+0.7071067811865475j)])
        self.endSequence = np.array([(0.7071067811865475+0.7071067811865475j), (0.7071067811865475+0.7071067811865475j), (0.7071067811865475-0.7071067811865475j),
                                    (-0.7071067811865475+0.7071067811865475j), (0.7071067811865475-0.7071067811865475j), (0.7071067811865475-0.7071067811865475j), 
                                    (-0.7071067811865475+0.7071067811865475j), (-0.7071067811865475-0.7071067811865475j), (-0.7071067811865475-0.7071067811865475j),
                                    (0.7071067811865475-0.7071067811865475j), (0.7071067811865475-0.7071067811865475j), (0.7071067811865475+0.7071067811865475j), 
                                    (0.7071067811865475-0.7071067811865475j), (0.7071067811865475+0.7071067811865475j), (-0.7071067811865475-0.7071067811865475j),
                                    (-0.7071067811865475+0.7071067811865475j), (-0.7071067811865475-0.7071067811865475j), (0.7071067811865475-0.7071067811865475j), 
                                    (-0.7071067811865475+0.7071067811865475j), (0.7071067811865475-0.7071067811865475j), (0.7071067811865475-0.7071067811865475j), 
                                    (-0.7071067811865475-0.7071067811865475j), (-0.7071067811865475-0.7071067811865475j), (0.7071067811865475-0.7071067811865475j), 
                                    (-0.7071067811865475-0.7071067811865475j), (0.7071067811865475+0.7071067811865475j), (0.7071067811865475+0.7071067811865475j), 
                                    (-0.7071067811865475+0.7071067811865475j), (-0.7071067811865475-0.7071067811865475j), (-0.7071067811865475+0.7071067811865475j), 
                                    (-0.7071067811865475-0.7071067811865475j), (0.7071067811865475-0.7071067811865475j)])


    def work(self, input_items, output_items):
        # get inputs
        rx_signal = input_items[0]
        start_index = 0
        end_index = len(rx_signal) - 1

        if rx_signal.size > 0:
            # correlate
            correlated_signal = fftconvolve(rx_signal, np.conj(np.flip(self.startSequence)), mode='full')
            end_cor_signal = fftconvolve(rx_signal, np.conj(np.flip(self.endSequence)), mode='full')

            # get indices
            start_index = np.argmax(np.abs(correlated_signal)) - 16*self.sps # go back 16 symbols e.g. 32 bits
            end_index = np.argmax(np.abs(end_cor_signal))

        # return the signal at those indices
        output_items[0][:] = rx_signal[start_index:end_index]
        
        return len(output_items[0])
